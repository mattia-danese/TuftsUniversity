           COMP 40 Lab: Unboxed and 2D Arrays


+--------------------------------------------------------+
|Keeper of the record: Mattia Danese                     |
|--------------------------------------------------------|
| Other group member(s): Nolan Feeley                    |
|                                                        |
|                                                        |
|                                                        |
+--------------------------------------------------------+


PART 1: BOXED AND UNBOXED ARRAYS
--------------------------------

You are about to design the interface and implementation for a
collection data type, i.e., an ADT like Hanson's, and you are
considering the tradeoffs between using a boxed or an unboxed
interface for values that users store in your collection.

1A: Briefly define the terms "boxed" and "unboxed" as used for these
    interfaces (i.e., help us be sure you know which is which!):

    Boxed interfaces deal with pointers to objects that are allocated
    somewhere else.
    Unboxed interfaces allocate and manage memory for its contents.

1B: List two (or more) advantages of the boxed representation.

    -  Contents won't get lost if container gets freed
    -  Changing the container won't affect the contents 

1C: List two (or more) advantages of an unboxed representation.

    -  The client is no longer responsible for freeing memory seperately
    -  Client no longer repsonsible for managing/owning container contents

1D: Look at the interface to UArray (a link to an interface
    summary is at the start of the lab instructions). Discuss the 
    methods that show the use of the unboxed style. Why, for example, 
    does UArray_new take both a number of elements and an element size? 

    
   UArray_free and UArray_new shows that allocation and deallocation
    is done by the container itself
    UArray_resize shows that the container has to be able to allocate 
    more space for its elements
    UArray_copy shows the same thing because it order to copy something, 
    you need to allocate space for the copied elements

   
    UArray_new takes length for the number of elements and size for the 
    amount of memory each element will take.
    This allows the container to allocate space for its contents


PART 2: 2D Arrays from 1D Arrays
--------------------------------

2A. One way to construct a 2D array is to use multiple 1D
    arrays. Describe briefly how you would do this. For example, if
    the user asked you to create a 5x7 array of values, how many
    one-dimensional arrays would you create? If the user asked to
    store a value in cell [3,6] where would it go?

    To make a 2D, you make each element in the first 1D array to be 
    another 1D array.
    
    For the 5x7 example, you would first make a 1D array of length 5 
    and populate each element with its own 1D array of length 7.
    8 1D arrays would be made. 
    
    The value would go in the 7th element of the 1D array stored in 4th
    entry of the original length 5 array 


2B. Another approach is to use a single one-dimensional array and to
    put all the elements of the 2D array into that. Again, assuming
    that you are to create a 7x5 2D array, give a mathematical formula
    for the index in the 2D array where a value [x,y] would go in the
    1D array.

    7x + y

2C. (optional) is there another mapping that would work as well?

    

PART 3: Designing the UArray2 Interface
---------------------------------------

3A. Describe three (or more) things you learned about the design and semantics
    of the UArray2 interface from reading useuarray2.c and from running
    correct_useuarray2.

   -  UArray2 can be access by either row or colunm major iteration
   -  UArray2 has a new method that takes dimensions sizes and an element 
      memory size
   -  UArray2 has methods to get width, height, and size
   -  UArray2 has two different map functions depending on whether you want 
      to map with row or column major
   -  UArray2_at returns a void pointer to the element at the index 
      supplied by its arguments





